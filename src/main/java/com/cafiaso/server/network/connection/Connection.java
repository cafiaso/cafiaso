package com.cafiaso.server.network.connection;

import com.cafiaso.server.network.protocol.io.FriendlyBuffer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.crypto.SecretKey;
import java.io.IOException;

/**
 * A connection between a client and the server.
 * <p>
 * The connection is established as soon as the client emits a ping or is trying to connect to the server
 * and is closed when the ping request has been handled or when the client disconnects from the server.
 */
public abstract class Connection {

    private static final Logger LOGGER = LoggerFactory.getLogger(Connection.class);

    private ConnectionState state = ConnectionState.HANDSHAKE;

    private Identity identity;

    private byte[] verifyToken;
    private SecretKey sharedSecret;

    /**
     * Reads data from the client and writes it to the given {@link FriendlyBuffer}.
     *
     * @param buffer the buffer to write data to
     * @return the number of bytes read
     * @throws IOException if an I/O error occurs while writing data
     */
    public abstract int read(FriendlyBuffer buffer) throws IOException;

    /**
     * Sends data from the given {@link FriendlyBuffer} to the client.
     * <p>
     * This method should block until all data is written.
     *
     * @param buffer the buffer to read data from
     * @throws IOException if an I/O error occurs while reading data
     */
    public abstract void write(FriendlyBuffer buffer) throws IOException;

    /**
     * Gets the IP address of the client.
     *
     * @return the IP address of the client
     */
    public abstract String getHostAddress();

    /**
     * Checks if the connection is still open.
     *
     * @return {@code true} if the connection is open, {@code false} otherwise
     */
    public abstract boolean isOpen();

    /**
     * Closes the connection.
     * <p>
     * When the connection is closed, it will no longer be able to read or write data.
     * <p>
     * This method will fail silently if the connection is already closed.
     *
     * @throws IOException if an error occurs while closing the connection
     */
    public abstract void close() throws IOException;

    /**
     * Gets the current {@link ConnectionState} of the connection.
     *
     * @return the current connection state
     */
    public ConnectionState getState() {
        return state;
    }

    /**
     * Sets the current {@link ConnectionState} of the connection.
     *
     * @param state the new connection state
     */
    public void setState(ConnectionState state) {
        LOGGER.debug("Connection state changed to {}", state);

        this.state = state;
    }

    /**
     * Gets the {@link Identity} of the client.
     * <p>
     * The identity is set during the login process and contains the client's username and UUID.
     *
     * @return the identity of the client
     */
    public Identity getIdentity() {
        return identity;
    }

    /**
     * Sets the {@link Identity} of the client.
     *
     * @param identity the identity of the client
     */
    public void setIdentity(Identity identity) {
        this.identity = identity;
    }

    /**
     * Gets the {@code verify token}. This is used to verify the client's identity.
     * <p>
     * This token is a random byte array generated by the server and sent to the client during the
     * EncryptionResponse packet handling.
     * The client must then send the token back to the server to prove its identity.
     *
     * @return the verify token, or {@code null} if the token has not been set yet
     */
    public byte[] getVerifyToken() {
        return verifyToken;
    }

    /**
     * Sets the {@code verify token}.
     *
     * @param verifyToken the verify token
     */
    public void setVerifyToken(byte[] verifyToken) {
        this.verifyToken = verifyToken;
    }

    /**
     * Gets the {@code shared secret} used to encrypt and decrypt packets sent between the client and the server.
     * <p>
     * The shared secret is set during the EncryptionResponse packet handling.
     *
     * @return the shared secret, or {@code null} if encryption is not enabled
     */
    public SecretKey getSharedSecret() {
        return sharedSecret;
    }

    /**
     * Sets the {@code shared secret}.
     *
     * @param sharedSecret the shared secret
     */
    public void setSharedSecret(SecretKey sharedSecret) {
        this.sharedSecret = sharedSecret;
    }
}
